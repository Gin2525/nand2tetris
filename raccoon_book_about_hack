● 機械語
機械語の基本欲求はただ一つ
「ハードウェア上で直接実行できること」である。

機械語はプロセッサとレジスタを用いてメモリを操作するように設計される。

● メモリ・プロセッサ・レジスタについて
メモリ
	固定幅のセルが連続して並んでいる。
	各セルは「ロケーション・ワード」と呼ばれる。
	各ワードについて普及する場合、
	Memory[address], RAM[address], M[address]
	と言った表現を行う
	
プロセッサ
	命令セットを実行することができる。
	命令セットには算術演算・論理演算・メモリアクセス演算・制御演算
	などが含まれる。
	
	命令セットを実行する際に必要なリソースの取得や情報の出力・記録はメモリ・レジスタに行われる。
	
レジスタ
	プロセッサと物理的に近接した場所にある、記憶領域
	メモリは一般にプロセッサとは切り離されて考えられる。
	そのため、IOにコストがかかる。これを是正するための領域がレジスタだ。

● アドレッシング
要求されたメモリのワードに対して、そのアドレスを指定する方法である。
コンピュータが異なれば、異なるアプローチが考えられる。

- 直接アドレッシング
- イミディエイトアドレッシング
- 関節アドレッシング

● 分岐命令
反復と条件分岐を実装する必要がある。
反復はループに関連があり、
条件分岐はいわゆる「if文」に関連がある。

まず、反復を実装するためにどうすればいいだろうか？
それには無条件分岐を知る必要がある。ある行に無条件にジャンプするということだ。

アセンブラでは、無条件に特定のラベルにジャンプするニーモニックと
条件に合致した場合のみ、特定のラベルにジャンプするニーモニックがある。

いわゆる「goto文」というやつだ。

● Hack機械語の仕様
前提として、16bitマシンである。

メモリについて
	二つの異なるアドレス空間がある。	命令メモリとデータメモリだ
	メモリの幅は16bitであり、アドレス空間は15bitを有している。
	つまりは2^15 = 32Kのサイズを有することになる

CPUは命令メモリにあるプログラムを実行することができる。逆にいうとそれしかできない。
この振る舞いから命令メモリはRead Onlyでいいことがわかるだろう

この仕様からわかることは「プログラムの読み込みには外部の仕組みを利用する」
ということだ。ゲーム機のカセットを入れ替えるのと同じことだ。

● ２つのレジスタ（Aレジスタ　と　Dレジスタ）
Aレジスタはデータメモリへ直接アクセスするために利用される

Hackの命令は16bitである。そのため、命令コードとアドレスと一つの命令に押し込むことは不可能
Hackの１命令 : 命令コード　＋　アドレス　（しかし、アドレスを直接アドレッシングすると幅が溢れる）

さて、どうしようか？ ここで、一つのルールを作る
D = M+1 （Mはメモリのアドレスとを指す）　といった操作をするときのMのアドレス値は Aレジスタ とする。
というものだ。これにより命令を16bit に収めることができる。

例えば
D = Memory[512] - 1 のような命令をしたいときに
まず、Aレジスタに512をセットし、
D = M - 1　を実行するのである。

ジャンプ命令を行うときにもこういったプロセスを経て、実行をおこなう。
つまりは、ジャンプ命令が実行されたときにジャンプする先は常にAレジスタである。
ということだ。

● Hackの例を見てみる
抑えるべきはA命令とC命令だ。

● A命令
Aレジスタに15bit の値を設定するために用いられる命令

	@i // A命令：Aレジスタにi(特定のメモリを指す値)が入れられる
	M=1 // C命令：Aレジスタがアドレッシングしている場所に１を代入する
	@sum　// A命令：Aレジスタにsum(メモリの特定の場所を参照している）を入れる
	M=0  // C命令：Aレジスタがアドレッシングしている場所に0	を代入する
	
このコードはC言語の表現の

	int i = 1;
	int sum = 0;

と対応づく

● C命令
ほとんど全ての仕事が、この命令によって行われる。

- 何を計算するか？
- 計算した結果をどこに格納するか？
- 次に何をするか？

これらの問いについて答えれるよう仕様が決まっている。

C命令： dest = comp ; jump

C命令は上のような構成である。
dest,あるいはjump は空である可能性がある。
もし、destがからであれば「＝」は省略される。
もし、jumpがからであれば、「;」 は省略される。

バイナリ：1 1 1 a	c1 c2 c3 c4    c5 c6 d1 d2    d3 j1 j2 j3

1 comp
comp領域ではALUに何を計算すべきかを命令する。
HackのALUは　Dレジスタ　Aレジスタ　Mレジスタに対して仕様で決められた操作を行う。
comp 領域は　a bit が１つ　c bit が６つある。
この計7bit で、ALUの関数と、操作対象のレジスタを決定する。

2 dest
領域は　3bit　である
dest : d1 d2 d3
d1　d2　は計算結果を　Aレジスタ　と　Dレジスタに格納するかどうかを指定する。
d3　は計算結果をMemory[Aレジスタの値]　に格納するか否かを指定する。
ニーモニックを見るとわかりやすいだろう。

3 jump
comp領域で計算が行われた後、「次に何を行うか」を決める
領域は 3bit である。
jump : j1 j2 j3
j1,j2,j3 は条件を指定する。

compで計算が行われた後、次に行われる動作は２つ考えられる
 プログラムの次の行をフェッチし、実行する。（こちらが標準的）
 プログラムのどこか他の場所に位置する命令をフェッチ、実行する
 
jumpは２を叶える。jump
